+++
tags  = ["letters"]
title = "\u9ad8\u901f\u5316\u65e5\u8a18 (8) - Load Average and Jiffies"
date  = "2020-01-25 15:19:38"
+++
<p>とある機能 F を有効にするととある操作 T のあとでコマ落ちするという、ユーザ（上司）の手元では再現するが手元での再現率がいまいちなバグを直そうと苦戦しつつはや数週間。</p><p>ハイレベルには、F を有効にした状態で操作 T をトリガーすると瞬間的に CPU の負荷が跳ね上がり、画像パイプラインのクリティカルパスにある HAL API である A のレイテンシがフレームレートを超えてしまい、コマ落ちに至る。</p><p>A のレイテンシは普段は余裕で予算に収まるのだが、他のタスクが増えると CPU のサイクルを奪われて遅くなる。症状から A の重要性は明らかなので A が動くスレッドを <a href="http://man7.org/linux/man-pages/man7/sched.7.html">SCHED_FIFO</a> にしましょうと主張してパッチを書いたが、OS のひとにインパクトでかすぎるのでダメと押し返されうーむとなる。</p><p>なお HAL の一部では SCHED_FIFO は<a href="https://cs.android.com/search?q=SCHED_FIFO&amp;sq=">ぼちぼち使われている</a>...まあ「ぼちぼち」は overstatement かもしれないですね。はい。従ってこの問題は <a href="https://source.android.com/devices/architecture/hidl/binder-ipc#rt-priority">priority inheritance</a> で解決されるのが筋だが、俺のせいじゃねー的 API のせいでその仕組みは使えないのだった。</p><p><hr /></p><p>それはさておき操作 T 発動時の CPU 負荷は機能 F の有無に関わらずどのみち高く、全てのコアが振り切る。機能 F のアルゴリズムが高価なのは事実だろうが、ほんとにコマ落ちの有無を決めるような規模のインパクトがあるのだろうか。こういう雑な仮説を盲目的に信じては痛い目に逢い続けて数年、いちおう検証しておこうと思い立つ。</p><p>タスクが多すぎてタイムスライスがもらえないとか、ロードアベレージみたいなのをみればいいんだっけ？と検索すると <a href="http://www.brendangregg.com/blog/2017-08-08/linux-load-averages.html">Brendan Gregg</a> のブログがヒット。要約すると Linux の load average の数字は微妙なので他の指標を使っときなよとのこと。他の指標としては BPF が使えるよ、とかいうが Android でそれは大変。別の候補として紹介されている  /proc/schedstat ファイルを polling してみることにする。</p><p><a href="https://github.com/torvalds/linux/blob/master/Documentation/scheduler/sched-stats.rst">ドキュメント</a>およびインターネットによると同ファイル内で "sum of all time spent waiting to run by tasks on this processor (in jiffies)" という数字を監視すればよいようだが、Jiffies ってなんやねん。その <a href="http://man7.org/linux/man-pages/man7/time.7.html">manpage</a> および<a href="https://stackoverflow.com/questions/2731463/converting-jiffies-to-milli-seconds">インターネット</a>によるとスケジューラのクロック、たとえば 100Hz だったら 10ms とからしい。なるほど・・・と値を眺めるが、全然合ってない。桁がいくつもちがう。最初は自分の雑なコードが計算ミスをしてるのかと思ったがそんなこともなさそうな雰囲気。はーなんだこりゃ・・・と落胆して帰宅。</p><p>翌日気を取り直してカーネルのコードを睨むと、数字の出どころは <a href="https://github.com/torvalds/linux/search?q=sched_clock&amp;unscoped_q=sched_clock">sched_clock()</a> という関数らしい。実装が複数あるのでよくわからないが、<a href="https://github.com/torvalds/linux/blob/master/Documentation/timers/timekeeping.rst">ドキュメント</a>は単位をナノ秒と主張している。 10ms と 1ns じゃだいぶ違うわけだわ・・・。ナノ秒として計算してみるとそれっぽい数字になる。やれやれ。カーネルのドキュメントも案外信用できない。</p><p><hr /></p><p>さてこうして計算したオレオレロードアベレージを定期的に <a href="https://developer.android.google.cn/ndk/reference/group/tracing">ATrace_setCounter()</a> しつつアプリをつついてトレースを眺めたところ・・・機能 F が有効だろうが無効だろうがロードに全然違いがない。</p><p>冷静になってトレースを見直すと機能 F はスレッドが一つ増えはするものの大した並列度はなく、そのスレッドも GPU に計算を投げたり他のスレッドの計算結果を待ったりで必ずしも全力では回っていない。仮説敗れる。はー・・・。</p><p>ではなぜ機能 F はコマ落ちを招くのだろうか。ユーザ（上司）の思い込み？でも自分の手元で問題がおきるときも機能 F の有無は影響ある気がするのだよなあ。</p><p><hr /></p><p>そして書いていて気づいたがトレースには sched の tracepoint が含まれているのだからカーネルが集めた stats を使うより自分で事後的に計算した方が色々わかることが多いきがする。たとえばカーネルの stats ではレイテンシの分布はわからない。ただその計算をするにはもうちょっとカーネル詳しくならんとムリだな。はー・・・。</p>
