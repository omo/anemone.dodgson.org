+++
tags  = ["letters","wa"]
title = "WA 2020 #3: Conway's Law of Thread Pools"
date  = "2020-02-15 07:26:30"
+++
<p>The mobile app I'm helping to build at work has stunning number of threads and it's been complained by the system health related teams, who are monitoring the apps built in the organization and alert their developers as needed.</p><p>One day, an engineer from <span style="text-decoration:underline;">a</span> neighbor<span style="text-decoration:underline;">ing</span> team filed a bug that sa<span style="text-decoration:underline;">id</span> "the app ha<span style="text-decoration:underline;">s</span> too many threads". I was furious - Their team<del>s</del> is responsible for large part of it, and you just throw the shit to us and ridicule us? What a rude guy. I was furious also because their team has been contributing to the app unstability for a long time and debugging it has wasted a lot of my time. But this kind of them-vs-us mindset never solves any issue, so I just left the bug open and moved on (which doesn't solve any issues either, literary, but at least I don't make it worse.)</p><p><hr></p><p>People casually create thread pools. In many cases that's not a problem. Each thread isn't <em>that</em> expensive after all. However, if a lot of teams who are developing compute-intensive features come together and put their efforts into <span style="text-decoration:underline;">a</span> single app, each increment is gradually harming the performance.</p><p>How expensive are threads? Talking about thread overhead, <span style="text-decoration:underline;">the</span> first thing people care <span style="text-decoration:underline;">about</span> is the memory. Thread does allocate some memory, but the actual number is not clear. In addition to the linux thread, <a href="https://android.googlesource.com/platform/art/+/master/runtime/thread.h">an ART thread</a> is attached to each thread on Android.</p><p>In practice though, the thread creation <em>latency</em> becomes more like a problem than the thread heap consumption. The thread creation is serialized, blocking other thread<span style="text-decoration:underline;">s</span>. Even without that, it does a lot at the beginning of the thread lifetime, and its CPU consumption is visible in a startup trace data.</p><p>In short: Thread<span style="text-decoration:underline;">s</span> can be heavy in memory, but thread creation latency is more evident harm.</p><p><hr></p><p>Why <span style="text-decoration:underline;">do</span> teams create <del>its</del><span style="text-decoration:underline;">their</span> own thread pool instead of sharing it? Because it's easier. Creating <span style="text-decoration:underline;">a</span> new one is one liner but passing around thread (or <a href="https://developer.android.com/reference/java/util/concurrent/Executor">Java Executor</a>) needs some plumbing, especially it crosses the team boundary. Also, it is often <em>safe</em> to have <span style="text-decoration:underline;">a</span> new one if you need specific semantics, like serialized execution on a single thread. Java doesn't have a way to express these characteristics of an Executor.</p><p>If you think a bit more, you would realize that you can implement the serialized semantics over an existing thread pool. Guava's <a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/util/concurrent/SequentialExecutor.java">SequentialExecutor</a> implements it for example. People just don't care. Another evidence that people don't care is that everyone creates the thread pool with number of thread as the device's CPU count. What a f*** - Multiply it with the number of thread <em>pools</em>. How does it possibly make sense. (I know it does in a few occasions, but it doesn't help me from the complaints from the other side.)</p><p>Java or Android could have had some API that return<span style="text-decoration:underline;">s</span> an Executor with desired property but is backed by a system-(or process-)wide thread pool. That didn't happen. Whom to curse?</p><p>Using native (C++) code in the app makes <span style="text-decoration:underline;">the</span> situation way worse: There is no obvious way to share threads (or thread pools) between C++ and Java. As a result, same people create separate thread pools in C++ in addition to ones in Java.</p><p><hr></p><p>The number of thread is now the number of CPU cores multiplied by the number of participating teams plus the number of async-but-serialized executions multiple by the number of programming languages. This is crazy. And that's why the number of thread<span style="text-decoration:underline;">s</span> in our app is crazy large.</p><p>Solving this problem is technically trivial: You can build a cross language thread pool library that <span style="text-decoration:underline;">has</span> thread sharing in mind. But it's more about organizational problem<span style="text-decoration:underline;">s</span>: You have to convince other team<span style="text-decoration:underline;">s</span> to use that library. You have to demand other teams extra work and complexity. You have to convince that your design is right, eschewing the endless bikeshedding, while you have deadlines, as well as do others.</p><p>I don't have energy to go through all of these, but probably I should start building something small and start using it in our own codebase, then go to the <del>rude</del> neighbor, and then pitch it to the research org, etc, etc... Oh god it's depressing. Stop thinking too much and just start small. Later.</p><p><hr></p><p>Another side of me appreciates where I am - It's much better to have at-least-partially-technical problems stacking up in front of myself, instead of having the need to look<del>ing</del> around to find even niche problems to solve, or having <del>a</del> not-at-all-technical problems in front of, but not reachable from, me. For me a hired professional, problems I have are bread and bacon.</p>
