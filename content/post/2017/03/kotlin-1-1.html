+++
tags  = []
title = "Kotlin 1.1"
date  = "2017-03-05 19:57:30"
+++
<p><a href="https://blog.jetbrains.com/kotlin/2017/03/kotlin-1-1/">来た</a>。ので手元の書きかけ Kotlin コードをちょっと書き換えてみる。ただ <a href="https://kotlinlang.org/docs/reference/coroutines.html">async/await</a> はまだちゃんと調べてないので後回し。type alias と bound callable references はすぐ使えて良い。</p><p>Bound callable reference, 便利だけどいよいよ currying 的なことがしたくなる。このへんの高階関数の扱いは Scala の方がいいなあ。JS ですら bind があるというのに...他はそんなに不満ないのだが。</p><p><hr /></p><p>結局 async/await というか Coroutine の資料も読んだ。<a href="https://kotlinlang.org/docs/reference/coroutines.html">この入門的な記事</a>を読み、次に適当にコードを参照しつつ<a href="https://github.com/Kotlin/kotlin-coroutines/blob/master/kotlin-coroutines-informal.md">詳しいバージョン</a>を読み、最後に<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md">高位の API の説明</a>を冷やかせばだいたいわかると思う。Kotlin は最近の言語に漏れず API リファレンスから GitHub のコードに飛べるのが便利だね。</p><p>Python の generator/coroutine をなんとなくわかってるという自分の理解からみた要点:</p><p><ul>
    <li>一番下にあるプリミティブは suspend キーワード, <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/-continuation/index.html">Continuation</a> インターフェイスと <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/suspend-coroutine.html">suspendCoroutine()</a> 関数。suspend キーワードのついた関数は、匿名クラスの Coroutine と、それを呼び出すスタブのメソッドを生成する。Coroutine の匿名クラスは Continuation インターフェイスを実装している。suspendCoroutine() を使うと、suspend 関数の中から自分自身の coroutine オブジェクトに (Continuation インターフェイスを介して) アクセスできる。このオブジェクトを非同期な API のコールバックから呼び出して継続する。</li>
    <li>Python の generator は suspend するたびに値を返せるが、Kotlin の Coroutine は最後に一つだけ値を返す。途中の suspend では値を返さない。buildSequence() などは generator みたいなもんだけど、これは coroutine のプリミティブの上でライブラリとして実装されている。</li>
    <li>Python の generator 関数は generator を返すが, Kotlin の suspend 関数は何も返さない。かわりに暗黙の引数として Continuation オブジェクトを渡す。CPS スタイルってそういえばこういうかんじだったかもしらん。</li>
</ul></p><p>第一印象。Python と比べると、後出しだけあって Kotlin の方がだいぶいいと感じる。整然としており、ドキュメントを 2,3 種類読んだだけで概要を把握できる。 Python の generator/coroutine はいくつ資料をよんでもなんとなくしかわからない。そしてそれは<a href="http://lucumr.pocoo.org/2016/10/30/i-dont-understand-asyncio/">自分だけではないっぽい</a>。</p><p>整然としているのは、まず JVM が変化せずコンパイラの力だけでがんばっているぶんレイヤリングがうまくできているおかげ。これは C# や JS もそうかな。コンパイラが生成するコードをなんとなく理解できれば一番下のレイヤがわかる。Python はインタプリタを拡張して色々やっているせいでシステムとして理解するのが辛い。</p><p>レイヤリングという点で、コンパイラの仕事や言語本体の拡張が割と小さいのも良い。Continuation インターフェイス、suspend キーワード、suspendContinuation() instrisics 関数。プリミティブはほぼこれだけで、あとはライブラリ。わかりやすい。他の言語はもうちょっといろいろ言語本体に入ってしまってるよね。たとえば JS の async/await は Promise とくっついている。</p><p>型が静的なのも良い。Python はある関数が generator かどうかを混同しがちで辛かった。動的型というのはそういうものだけれど、実行時にしかわからないバグの原因が増えると動的型でがんばるの段々辛くなっていく。Kotlin は suspend 関数を間違ったコンテクストで呼ぶことはできないので安心。</p><p><hr /></p><p>Java 資産との乖離が心配だったけれど, ライブラリの API が RxJava など限られた非同期フレームワークに集約されている限りは <a href="https://github.com/Kotlin/kotlinx.coroutines/tree/master/kotlinx-coroutines-rx2">RxJava と coroutine の interop</a> を使えるので割と大丈夫なかんじ。ハードコア Kotlin プログラマは coroutine をばりばりつかったライブラリとかを作りたいだろうけれど、ライブラリは Java と Rx にしておきアプリのレイヤでだけ coroutine をつかうくらいが無難な気がする。</p><p>Kotlin 1.1 ではまた experimental というから様子見。そのうち思い出したにはいいかんじに普及していることでしょう。</p><p>&nbsp;</p>
