+++
tags  = ["mld"]
title = "A Mental Model of TF"
date  = "2017-08-12 21:34:14"
+++
<p>自分が抱いている TensorFlow のメンタルモデルを書き下してみる。現時点での自分の理解を整理記録するのが目的なので、正しいことは期待していない。</p><p><hr /></p><p>TF はある種の言語処理系、インタプリタである。専用の文法はなく、プログラムは Python の DSL として与えられる。TF の Model はその TF 言語で書かれたプログラム。プログラムは Session を通じて実行できる。</p><p>プログラミング言語としてみた TF 言語の表現能力は高くない。たとえば関数とかは定義できない (ほんとに?)。再帰もない気がする(ほんとに?)。Ops と呼ばれるプリミティブを式として組み合わせて何かを計算するのがもっぱら。Ops はプリミティブなので TF 言語自体では定義できない。ただし C++ や Python で拡張することはできる。SQL の UDF を定義するようなもの。まあ SQL の UDF は SQL で定義できるのかもしれないが。誰得。</p><p>TF 言語はプログラム内の式の微分を計算できる。それが典型的なプログラミング言語と大きく異なる。この機能を実現するため、全ての Ops は自分の微分を定義しないといけない。(たぶん全てではない。微分要不要の境目はなに?)</p><p>とはいえたとえば BUGS のような特殊なドメイン言語は微分じゃないけど似たような特別な性質を持っているので、すごく珍しい話ではない。</p><p>TF 言語はまた、並列化や分散化、永続化などを組み込みでサポートしている。これは Python をネイティブ言語とする PyTorch などとは異なるところ。DSL として自分の言語を持った強みと言える。かわりに分岐とかループとかを書くのがめんどいのが欠点。</p><p>DSL として言語/モデルをわけておく別の利点は、Python のレイヤでメタプログラミング的なことがやりやすいこと。たとえば Model/Variable の save とかで保存したいノードを選ぶ、みたいなコードを普通にかける。他の言語だと compiler plugin とか macro とか reflection になりがちな部分が普通に触れる。一方で普段から reflection だけでコードを書かされているだけなのでは、というツッコミはありうる。Lisper と Haskeller だけがこのぎこちなさをディスって良い。</p><p><hr /></p><p>と書き出してみると、主張の正しさも何も肝心なところはまったく理解してないと思い至る。</p><p>たとえば TF 言語処理系だというなら、そのインタプリタはどのように実装されているのか。プリミティブのうち、本当にプリミティブなものは何で、どこからが sugar なのか。たとえば Variable というのはどのくらい特別な存在なのか。Optimizer はどのように動くのか。Saver で保存される Variables と GraphDef はどんな関係があるのか。などなど・・・。</p><p>そのうちコードでも読んだほうがいいんだろうけど、まあ当面は基礎を地道にやります。はい。</p>
